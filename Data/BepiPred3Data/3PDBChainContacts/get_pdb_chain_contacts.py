### IMPORTS ###
from Bio.PDB import *
import pickle
from pathlib import Path
from statistics import mode
import sys
import shutil

#Input: a list of pdb accs.
#Output: Antibody and antigen sequences where the interaction sites are marked with capital letters. 
#save antibody and antigen sequences in separate files

### Pseudocode ###
#go through accesions resulting from Pisces dunbrack
#Use light and heavy chain lists generated by get_ag_ab_complexes.py,
#to figure which chains belong to the antibody. Anything remaining is the antigen. 

### COMMAND LINE ARGUMENTS ###

### STATIC STUFF ###

#argument for pdb acession after bad quailty removal and sequence clustering.
ROOT_DIR = Path.cwd()

#results needed from 1AgABComplexCandsFromPDB
HMM_results = ROOT_DIR / "../1AgABComplexCandsFromPDB/Results/"
HMM_results = HMM_results.resolve()

#these accesions allow for identification of the light, heavy and antigen chain
heavy_chain_acc_path = HMM_results / "HeavyChainAcc.pickle"
light_chain_acc_path = HMM_results / "LightChainAcc.pickle"
heavy_light_chain_intersection_acc_path = HMM_results / "LightHeavyChainIntersectionAcc.pickle"
no_HMM_hit_chain_acc_path = HMM_results / "NoHMMHitChainAcc.pickle"
all_HMM_chain_acc_path = HMM_results / "AllChainAccs.pickle"

#results from 2FilterBadQualityStructures
quality_filtering = ROOT_DIR / "../2FilterBadQualityStructures/"
quality_filtering = quality_filtering.resolve()
SABDAB_PDB_file_path = quality_filtering / "SABDABHITS"
HMM_SABDAB_acc_intersection_path = quality_filtering / "Results" / "hmm_sabdab_intersection.pickle"
HMM_SABDAB_acc_extra_intersection_path = quality_filtering / "Results" / "hmm_sabdab_extra_intersection.pickle"
HMM_acc_path = quality_filtering / "Results" / "hmm_set.pickle"
SABDAB_acc_path = quality_filtering / "Results" / "sabdab_set.pickle"


for directories in (HMM_results, quality_filtering):
    if not directories.is_dir():
        sys.exit(f"One of theOne of the neccessary directories could not be found.\nThe directory not found: {directories}")
for files in (heavy_chain_acc_path, light_chain_acc_path, heavy_light_chain_intersection_acc_path,
        no_HMM_hit_chain_acc_path, all_HMM_chain_acc_path, HMM_SABDAB_acc_intersection_path,HMM_SABDAB_acc_extra_intersection_path,
        HMM_acc_path, SABDAB_acc_path):
    if not files.is_file():
        sys.exit(f"One of the neccessary files could not be found. Was 1AgABComplexCandsFromPDB and 2FilterBadQualityStructures completed?\nThe file not found: {files}")

#reading prior results
with open(heavy_chain_acc_path, "rb") as infile:
    heavy_chain_acc = pickle.load(infile)
with open(light_chain_acc_path, "rb") as infile:
    light_chain_acc = pickle.load(infile)
with open(heavy_light_chain_intersection_acc_path, "rb") as infile:
    heavy_light_chain_intersection_acc = pickle.load(infile)
with open(no_HMM_hit_chain_acc_path, "rb") as infile:
    no_HMM_hit_chain_acc = pickle.load(infile)
with open(all_HMM_chain_acc_path, "rb") as infile:
    all_HMM_chain_acc = pickle.load(infile)
with open(HMM_SABDAB_acc_intersection_path, "rb") as infile:
    HMM_SABDAB_acc_intersection = pickle.load(infile)
with open(HMM_SABDAB_acc_extra_intersection_path, "rb") as infile:
    HMM_SABDAB_acc_extra_intersection = pickle.load(infile)
with open(HMM_acc_path, "rb") as infile:
    HMM_acc = pickle.load(infile)
with open(SABDAB_acc_path, "rb") as infile:
    SABDAB_acc = pickle.load(infile)

#results directory
target_dir = ROOT_DIR / "Results"

try:
    target_dir.mkdir(exist_ok=False)
except FileExistsError:
    print(f"Directory: {target_dir}\nAlready existed. Overwriting results.")
    shutil.rmtree(target_dir)
    target_dir.mkdir(exist_ok=False)
else:
    print(f"Directory: {target_dir}\nNot found. Creating one.")

### FUNCTIONS ###
def get_antibodies(light_chains, heavy_chains):
    """
    Takes following inputs and outputs for one PDB model
    Inputs: light_chains: List of light chain ids e.g. [<Light Chain id=A>, <Light Chain id=C>...]
            heavy_chains: List of heavy chain e.g. [<Heavy Chain id=B>, <Heavy Chain id=D>...]
    Outputs: antibodies: List of tuples for light and heavy chain pairs e.g. [(<Chain id=A>, <Chain id=B>), (<Chain id=C>, <Chain id=D>) ]
    """
     
    antibodies = list()
    for light_chain in light_chains:
        #query against current light chain
        light_chain_atoms = Selection.unfold_entities(light_chain, "A")
        search_object = NeighborSearch(light_chain_atoms)
        #go through each heavy chain
        light_chain_list = list()
        heavy_chain_list = list()
        for heavy_chain in heavy_chains:
            heavy_chain_atoms = Selection.unfold_entities(heavy_chain, "A")
            #go through each heavy chain atom and check for light chain residues within 3 Ångstrøm.
            for heavy_chain_atom in heavy_chain_atoms:
                search_object_neighbors = search_object.search(heavy_chain_atom.coord, radius = 3.5, level="R")
                if search_object_neighbors:
                    light_chain_list.extend(Selection.unfold_entities(search_object_neighbors, "C"))
                    heavy_chain_list.append(heavy_chain)

        #put together light chain and heavy chain pairs
        antibodies.append( (mode(light_chain_list), mode(heavy_chain_list)) )

    return antibodies

def annotate_AA_seq(residues, epitope_or_paratope_res):
    """
    Inputs: residues: List of Bio PDB residue class objects.
            epitope_or_paratope_res: List of Bio PDB residue class objects
    Outputs: annotated_AA_seq: String of amino acid characters where,
                               capitalized letter = Epitope/Paratope residue
                               non-capitalized letter = Non-epitope/Non-paratopee residue.
                               x/X are non amino acid characters, such as DNA or RNA.
    """
    annotated_AA_seq = str()
    for residue in residues:
        try:
            aa = Polypeptide.three_to_one(residue.get_resname())
        #when residue is something nonstandard
        except KeyError:
            aa = "x"
        
        if residue in epitope_or_paratope_res:
            aa = aa.upper()
        else:
            aa = aa.lower()
        annotated_AA_seq += aa
    
    return annotated_AA_seq


def get_single_chain_antibody_antigen_interaction(heavy_light_chains, antigen, pdb_acc):
    
    antigen_antibody_interactions = list()
    antigens_epitopes = str()

    for antigen in antigens:
        antigen_epitope_residues = list()
        antigen_id = f"{pdb_acc}_{antigen.get_id()}"
        antigen_atoms = Selection.unfold_entities(antigen, "A")
        antigen_residues = Selection.unfold_entities(antigen, "R")
        search_object = NeighborSearch(antigen_atoms)

        for heavy_light_chain in heavy_light_chains: 
            antibody_specific_epitope_residues = list()
            heavy_light_chain_paratope_residues = list()
            heavy_light_chain_id = f"{pdb_acc}_{heavy_light_chain.get_id()}"
            heavy_light_chain_atoms = Selection.unfold_entities(heavy_light_chain, "A")

            #get antigen interaction
            #get antigen interaction with light chain
            for heavy_light_chain_atom in heavy_light_chain_atoms:
                epitope_residue = search_object.search(heavy_light_chain_atom.coord, radius = 4, level="R")
                if epitope_residue:
                    if heavy_light_chain_atom.is_disordered():
                        print(f"Disordered atoms detected in antigen-antibody interaction site.")
                        pass
                    else:
                        #get epitope residues
                        antigen_epitope_residues.extend(epitope_residue)
                        antibody_specific_epitope_residues.extend(epitope_residue)
                        #get heavy_light paratope residue
                        heavy_light_chain_paratope_residue = Selection.unfold_entities(heavy_light_chain_atom, "R")
                        heavy_light_chain_paratope_residues.extend(heavy_light_chain_paratope_residue)

            #creating annotated heavy light chain string
            heavy_light_chain_residues = Selection.unfold_entities(heavy_light_chain, "R")
            heavy_light_chain_annotated_seq = annotate_AA_seq(heavy_light_chain_residues, heavy_light_chain_paratope_residues)
            #creating annotated antigen string
            antigen_annotated_seq = annotate_AA_seq(antigen_residues, antibody_specific_epitope_residues)
            
            antigen_antibody_interaction = (heavy_light_chain_id, heavy_light_chain_annotated_seq, antigen_id, antigen_annotated_seq)
            antigen_antibody_interactions.append(antigen_antibody_interaction)


        #annotate antigen epitopes with all antibodies in fasta format
        antigens_epitopes += f">{antigen_id}\n"
        antigens_epitopes += annotate_AA_seq(antigen_residues, antigen_epitope_residues)
        antigens_epitopes += "\n"

    return antigens_epitopes, antigen_antibody_interactions 


def get_antibody_antigen_interaction(antibodies, antigen, pdb_acc):
    """
    Inputs: antibodies: List of tuples for light and heavy chain pairs e.g. [(<Light Chain id=A>, <Heavy Chain id=B>), (<Light Chain id=C>, <Heavy Chain id=D>) ]
            antigens: List of antigens e.g. [<Chain id=A>, <Chain id=C>...]
            pdb_acc: PDC accession. Used when saving results.
    Outputs: all_interaction_with_antigens: String. For each antigen, save all interactions with antibodies. Epitopes are annotated with capilized AA characters. 
             antigen_antibody_interactions: List of tuples. For each antibody-antigen, save epitopes, light chain paratope and heavy chain paratope
                                            [(light_chain_id, light_chain_annotated_string, heavy_chain_id, heavy_chain_annotated_string,
                                            antigen_id, antigen_annotated_string)]
    """

    antigen_antibody_interactions = list()
    antigens_epitopes = str()

    for antigen in antigens:
        antigen_epitope_residues = list()
        antigen_id = f"{pdb_acc}_{antigen.get_id()}"
        antigen_atoms = Selection.unfold_entities(antigen, "A")
        antigen_residues = Selection.unfold_entities(antigen, "R")
        search_object = NeighborSearch(antigen_atoms)

        for antibody in antibodies:
            antibody_specific_epitope_residues = list()
            light_chain_paratope_residues = list()
            heavy_chain_paratope_residues = list()

            light_chain = antibody[0]
            heavy_chain = antibody[1]
            light_chain_id = f"{pdb_acc}_{light_chain.get_id()}"
            heavy_chain_id = f"{pdb_acc}_{heavy_chain.get_id()}"

            light_chain_atoms = Selection.unfold_entities(light_chain, "A")
            heavy_chain_atoms = Selection.unfold_entities(heavy_chain, "A")

            #get antigen interaction with light chain
            for light_chain_atom in light_chain_atoms:
                epitope_residue = search_object.search(light_chain_atom.coord, radius = 4, level="R")

                if epitope_residue:

                    if light_chain_atom.is_disordered():
                        print(f"Disordered atoms detected in antigen-antibody interaction site, on light chain")
                        pass
                    else:
                        #get epitope residues
                        antigen_epitope_residues.extend(epitope_residue)
                        antibody_specific_epitope_residues.extend(epitope_residue)
                        #get light paratope residue
                        light_chain_paratope_residue = Selection.unfold_entities(light_chain_atom, "R")
                        light_chain_paratope_residues.extend(light_chain_paratope_residue)

           #get antigen interaction with heavy chain
            for heavy_chain_atom in heavy_chain_atoms:
                epitope_residue = search_object.search(heavy_chain_atom.coord, radius = 4, level="R")
                if epitope_residue:

                    if heavy_chain_atom.is_disordered():
                        print(f"Disordered atoms detected in antigen-antibody interaction site, on heavy chain")
                        pass
                    else:
                        #getepitope residues
                        antigen_epitope_residues.extend(epitope_residue)
                        antibody_specific_epitope_residues.extend(epitope_residue)
                        #get heavy paratope residue
                        heavy_chain_paratope_residue = Selection.unfold_entities(heavy_chain_atom, "R")
                        heavy_chain_paratope_residues.extend(heavy_chain_paratope_residue) 

            #creating annotated light chain string
            light_chain_residues = Selection.unfold_entities(light_chain, "R")           
            light_chain_annotated_seq = annotate_AA_seq(light_chain_residues, light_chain_paratope_residues) 
            #creating annotated light chain string
            heavy_chain_residues = Selection.unfold_entities(heavy_chain, "R")
            heavy_chain_annotated_seq = annotate_AA_seq(heavy_chain_residues, heavy_chain_paratope_residues)
            #creating annotated antigen string
            antigen_annotated_seq = annotate_AA_seq(antigen_residues, antibody_specific_epitope_residues)
            #create tuple with specific antigen-antibody interactions 
            antigen_antibody_interaction = (light_chain_id, light_chain_annotated_seq,
                    heavy_chain_id, heavy_chain_annotated_seq,
                    antigen_id, antigen_annotated_seq)
            #append tuplpe to list
            antigen_antibody_interactions.append(antigen_antibody_interaction)
        
        #annotate antigen epitopes with all antibodies in fasta format
        antigens_epitopes += f">{antigen_id}\n"
        antigens_epitopes += annotate_AA_seq(antigen_residues, antigen_epitope_residues)
        antigens_epitopes += "\n"

    return antigens_epitopes, antigen_antibody_interactions 

def get_and_remove_heteroatoms(chain):
    """
   Heteroatoms in the form of water and other solvents need to be removed from the chain.
   Inputs: chain id

    """
    #for checking chain dict()
    #print(chain.child_dict)
    #print(chain.child_dict.keys())
    residues = Selection.unfold_entities(chain, "R")
    heteroatom_residue_ids = list()
    for residue in residues:
        residue_id = residue.get_full_id()

        #residue is a heteroatom
        if residue_id[3][0] != " ":
            heteroatom_residue_ids.append(residue_id[3])
    #remove all heteroatoms
    [chain.detach_child(ids) for ids in heteroatom_residue_ids]


### MAIN: GO THROUGH PDB ACCESSIONS AND OBTAIN RESIDUE-RESIDUE CONTACTS ###

parser = PDBParser()
ppb = PPBuilder()
SABDAB_PDB_files = list(SABDAB_PDB_file_path.glob("*.pdb"))
num_SABDAB_PDB_files = len(SABDAB_PDB_files)
all_antigens_epitopes = str()
all_antigen_antibody_interactions = list()
unidentified_chains = str()
high_quality_accs_not_in_HMM_search = list()
HMM_SABDAB_extra_pdb_files = list()

i = 1

for pdb_file in SABDAB_PDB_files:
    pdb_acc = pdb_file.stem
    print(f"{pdb_acc}: {i}/{num_SABDAB_PDB_files}")

    if pdb_acc not in HMM_SABDAB_acc_intersection and pdb_acc not in HMM_SABDAB_acc_extra_intersection:
        print(f"{pdb_acc}: accesion not found in HMM profiling but in SABDAB database. Saving to list of high qualtiy accs.")
        high_quality_accs_not_in_HMM_search.append(pdb_acc)

    elif pdb_acc in HMM_SABDAB_acc_extra_intersection:
        print(f"{pdb_acc}: accesion found in extra candidates for HMM profiling. Saving acc to list for later")
        HMM_SABDAB_extra_pdb_files.append(pdb_file)
 
    elif pdb_acc in HMM_SABDAB_acc_intersection:
        structure = parser.get_structure(pdb_acc, pdb_file)

        for model in structure:
            light_chains = []
            heavy_chains = []
            antigens = []

            for chain in model:
                chain_id = f"{pdb_acc}_{chain.get_id()}"

                #remoeve heteroatoms (waters and solvents)
                residues = Selection.unfold_entities(chain, "R")
                print(f"Chain length before removing waters and solvent: {len(residues)}")
                get_and_remove_heteroatoms(chain)
                residues = Selection.unfold_entities(chain, "R")
                print(f"Chain length after removing waters and solvent: {len(residues)}")

                if len(residues) == 0:
                    print("After removing water and solvent, chain had 0 resiudes. Passing on this chain")
                    pass
                elif chain_id in light_chain_acc:
                    light_chains.append(chain)
                    print(f"{chain_id} is a light chain")
                elif chain_id in heavy_chain_acc:
                    heavy_chains.append(chain)
                    print(f"{chain_id} is a heavy chain")
                elif chain_id in no_HMM_hit_chain_acc:
                    antigens.append(chain)
                    print(f"{chain_id} is an antigen")
                #there may be chain_ids which arent in all_HMM_chain_acc, because they come from a different model.
                elif chain_id not in all_HMM_chain_acc:
                    seq = ppb.build_peptides(chain)[0].get_sequence()
                    unidentified_chains += f"{chain_id}\n{seq}\n"

            #if light, heavy and antigen chains have been identified
            if light_chains and heavy_chains and antigens:

                num_light_chains = len(light_chains)
                num_heavy_chains = len(heavy_chains)

                if num_light_chains != num_heavy_chains:
                    print(f"Inconsistent number of heavy and light chains\nNumber of light chains: {num_light_chains}\nNumber of heavy chains: {num_light_chains}")

                #if there is only one heavy and light chain.
                if len(light_chains) == 1 and len(heavy_chains) == 1: 
                    antibodies = list(zip(light_chains, heavy_chains))
                #if there are multiple antibodies, find pairs of antibodies by checking which light and heavy chains are closest to each other.
                else:
                    antibodies = get_antibodies(light_chains, heavy_chains)
                
                #get antigen epitopes ag-ab interactions
                ag_epitopes, ag_ab_interactions = get_antibody_antigen_interaction(antibodies, antigens, pdb_acc)
                all_antigens_epitopes += ag_epitopes
                all_antigen_antibody_interactions.extend(ag_ab_interactions)

    i += 1

print("Going through extra AG-AB complex candidates")
i = 1
num_SABDAB_extra_PDB_files = len(HMM_SABDAB_extra_pdb_files)

for pdb_file in HMM_SABDAB_extra_pdb_files:
    print(f"{pdb_acc}: {i}/{num_SABDAB_extra_PDB_files}")
    pdb_acc = pdb_file.stem
    structure = parser.get_structure(pdb_acc, pdb_file)
    #Do something about these files
    for model in structure:
        light_heavy_chains = []
        antigens = []
        for chain in model:
            chain_id = f"{pdb_acc}_{chain.get_id()}"
            #remoeve heteroatoms (waters and solvents)
            residues = Selection.unfold_entities(chain, "R")
            print(f"Chain length before removing waters and solvent: {len(residues)}")
            get_and_remove_heteroatoms(chain)
            residues = Selection.unfold_entities(chain, "R")
            print(f"Chain length after removing waters and solvent: {len(residues)}")
            
            if len(residues) == 0:
                print("After removing water and solvent, chain had 0 resiudes. Passing on this chain")
                pass

            elif chain_id in heavy_light_chain_intersection_acc:
                light_heavy_chains.append(chain)
                print(f"{chain_id} is a light/heavy chain")
            elif chain_id in no_HMM_hit_chain_acc:
                antigens.append(chain)
                print(f"{chain_id} is a antigen")
            elif chain_id not in all_HMM_chain_acc:
                seq = ppb.build_peptides(chain)[0].get_sequence()
                unidentified_chains += f"{chain_id}\n{seq}\n"

        if light_heavy_chains and antigens:
            ag_epitopes, ag_ab_interactions = get_single_chain_antibody_antigen_interaction(light_heavy_chains, antigens, pdb_acc)
            all_antigens_epitopes += ag_epitopes
            all_antigen_antibody_interactions.extend(ag_ab_interactions)
    i += 1

#save all antigens and their epitopes in fasta format
with open(target_dir / "antigens_with_epitopes.fasta", "w") as outfile:
    outfile.write(all_antigens_epitopes)
#save all antibody-antigen interactions
with open(target_dir / "antigens_antibody_interactions.pickle", "wb") as outfile:
    pickle.dump(all_antigen_antibody_interactions, outfile)
#save list of high quality accs not found in HMM profiling
with open(target_dir / "high_quality_accs.list", "w") as outfile:
    for acc in high_quality_accs_not_in_HMM_search:
        outfile.write(f"{acc}\n")
#save fasta formated file of unidentified chains 
with open(target_dir / "unidentified_chains.fasta", "w") as outfile:
        outfile.write(unidentified_chains)
